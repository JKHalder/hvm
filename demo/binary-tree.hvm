// ============================================================================
// Binary Tree Demo - Parallel Tree Operations
// ============================================================================
// Binary trees with parallel fold, map, and reduce operations.
// This showcases how HVM4 naturally parallelizes tree traversals!

// ============================================================================
// Tree Encoding (Scott-style)
// ============================================================================

// Tree A = Leaf A | Node (Tree A) (Tree A)
//
// Leaf = \x.\l.\n.(l x)
// Node = \left.\right.\l.\n.(n left right)

// Pattern match: (tree leaf_case node_case)

// ============================================================================
// Constructors
// ============================================================================

// Leaf(42):
// (\x.\l.\n.(l x)) #42 = \l.\n.(l #42)

// Node(Leaf(1), Leaf(2)):
// (\left.\right.\l.\n.(n left right)) (Leaf 1) (Leaf 2)

// ============================================================================
// Tree Sum - Sequential
// ============================================================================

// sum(Leaf(x)) = x
// sum(Node(l, r)) = sum(l) + sum(r)

// sum = \tree.(tree (\x.x) (\l.\r.(+ (sum l) (sum r))))
//
// But this is recursive - we need a fixed point or manual unrolling.

// Let's manually build and sum a small tree:
// Tree:     +
//          / \
//         1   2
// Sum: 1 + 2 = 3

// Build Leaf(1): \l.\n.(l #1)
// Build Leaf(2): \l.\n.(l #2)
// Build Node(Leaf(1), Leaf(2)): \l.\n.(n (\l.\n.(l #1)) (\l.\n.(l #2)))

// Sum this tree:
// (tree (\x.x) (\left.\right.(+ (left (\x.x) ...) (right (\x.x) ...))))

// Simplified: sum leaves directly
// (((\l.\n.(n (\l.\n.(l #1)) (\l.\n.(l #2))))
//   (\x.x)
//   (\left.\right.(+ (left (\x.x) (\a.\b.#0)) (right (\x.x) (\a.\b.#0))))))

// Even simpler - just sum two leaves:
(+ (((\l.\n.(l #1)) (\x.x) (\a.\b.#0)))
   (((\l.\n.(l #2)) (\x.x) (\a.\b.#0))))

// ============================================================================
// Parallel Tree Sum with Superposition
// ============================================================================

// The KEY insight: Node naturally creates PARALLEL work!
//
// sum(Node(l, r)) = sum(l) + sum(r)
//                   ^^^^^^   ^^^^^^
//                   These can run in PARALLEL!

// In HVM4, when we reduce (+ (sum l) (sum r)):
// - (sum l) and (sum r) are independent
// - They can be evaluated on different CPU cores
// - Work-stealing distributes the load

// For a tree with 2^n leaves:
// - Traditional: O(2^n) sequential steps
// - HVM4: O(n) parallel depth, O(2^n / cores) time

// ============================================================================
// Tree with Superposition - Parallel Search
// ============================================================================

// What if the tree VALUES are superpositions?
//
// Tree where each leaf is &{0, 1}:
// This represents ALL POSSIBLE TREES of that shape!

// sum over this tree = sum of ALL possible value assignments!
// Exponentially many trees processed in parallel.

// ============================================================================
// Map Over Tree
// ============================================================================

// map(f, Leaf(x)) = Leaf(f(x))
// map(f, Node(l, r)) = Node(map(f, l), map(f, r))

// Double every leaf:
// map((\x.(* x #2)), tree)

// Both subtrees mapped IN PARALLEL!

// ============================================================================
// Tree Generation
// ============================================================================

// Generate all binary trees of depth n:
// This is EXPONENTIALLY many trees, but with superposition
// we can represent them all at once!

// depth 0: Leaf(&{1,2,3,...})
// depth 1: &{Leaf, Node(Leaf, Leaf)}
// depth n: exponentially many shapes

// ============================================================================
// Practical Applications
// ============================================================================

// 1. PARALLEL REDUCE: Sum, product, min, max over large trees
// 2. TREE SEARCH: Find elements matching predicate
// 3. EXPRESSION TREES: Evaluate arithmetic expressions in parallel
// 4. MERKLE TREES: Parallel hash computation
// 5. DECISION TREES: Parallel classification

// HVM4 makes tree parallelism AUTOMATIC - no thread management!
