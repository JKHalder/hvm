// ============================================================================
// SKI Combinator Calculus Demo
// ============================================================================
// The SKI combinators form a Turing-complete basis for computation.
// Any lambda term can be expressed using just S, K, and I!
//
// I = \x.x                    (Identity)
// K = \x.\y.x                 (Constant)
// S = \x.\y.\z.((x z) (y z))  (Substitution)

// ============================================================================
// I Combinator - Identity
// ============================================================================
// I x = x
// ((\x.x) #42) = #42
((\x.x) #42)

// ============================================================================
// K Combinator - Constant
// ============================================================================
// K x y = x (returns first argument, ignores second)
// (((\x.\y.x) #1) #2) = #1
// (((\x.\y.x) #1) #2)

// ============================================================================
// S Combinator - Substitution
// ============================================================================
// S x y z = (x z) (y z)
// It applies z to both x and y, then applies the results

// S K K = I (famous identity!)
// S K K x = ((K x) (K x)) = x
// Let's verify: S = \x.\y.\z.((x z) (y z))
// S K K = \z.((K z) (K z)) = \z.z = I

// (((\x.\y.\z.((x z) (y z))) (\a.\b.a)) (\c.\d.c))
// Applied to #42 should give #42
// ((((\x.\y.\z.((x z) (y z))) (\a.\b.a)) (\c.\d.c)) #42)

// ============================================================================
// B Combinator - Composition
// ============================================================================
// B = \f.\g.\x.(f (g x))
// B f g x = f (g x) -- function composition

// B (+1) (*2) 5 = (+1) ((*2) 5) = (+1) 10 = 11
// ((((\f.\g.\x.(f (g x))) (\a.(+ a #1))) (\b.(* b #2))) #5)

// ============================================================================
// C Combinator - Flip
// ============================================================================
// C = \f.\x.\y.((f y) x)
// C f x y = f y x -- flips arguments

// C (-) 3 10 = ((-) 10) 3 = 10 - 3 = 7
// ((((\f.\x.\y.((f y) x)) (\a.\b.(- a b))) #3) #10)

// ============================================================================
// W Combinator - Duplicate
// ============================================================================
// W = \f.\x.((f x) x)
// W f x = f x x -- applies x twice

// W (+) 21 = (+) 21 21 = 42
// (((\f.\x.((f x) x)) (\a.\b.(+ a b))) #21)

// ============================================================================
// Omega - Non-termination
// ============================================================================
// omega = \x.(x x)
// Omega = omega omega = (\x.(x x)) (\x.(x x))
// This loops forever! Don't run it:
// ((\x.(x x)) (\x.(x x)))
